# React 中的设计理论

React 的生态万紫千红, 可谓是繁花似锦; 从这些框架及工具中衍生了各种的设计模式及理论知识, 本文就来盘点记录下相关的知识点

## 组件设计

如今各种前端框架均统一了组件化的思维, 面试中也会被问到, 如何设计一个组件(库), 笔者认为应该分为以下几个部分:

- 贯彻单一职责的原则

- 组件的通信和封装

- 组件的可组合性

- 组件的可测试性

- 组件的归类分类

- 组件的命名规范

### 单一职责原则

良好的设计中, 一个组件只干一件事情; 单一职责在组件中决定了组件如何拆分; 保持组件的单一职责将会非常重要，甚 至我们可以使用 HoC 强制组件的单一职责性。

### 组件的通信和封装

这块涉及到组件的参数设计、输入校验检查等， 也就是组件的健壮性；封装性决定了组件如何组织结构;

### 组件的可组合性

这块设计到整个组件如何拼接整个应用, 也就是组件的可复用性和扩展性;

### 组件的可测试性

良好的组件设计会让自动化测试变得异常简单, 这也涉及到良好的组件拆分

### 多组件的分类

如果需要设计一个组件库, 需要考虑的组件的拆分, 将组件分为纯组件和非纯(副作用)组件, 也就是对应`React`中的`Dumb`和`Smartß`组件

### 组件的命名规范

最后一步讲组件的命名, 主要是这块大多数人都觉得可有可无不重要, 其实良好的组件设计中, 组件名应该是能够见名知意的

## 状态管理

现在各种主流框架都会有各种的状态管理库, 而且框架中亦能自己管理状态; 所以问题就来了: **到底什么样的状态用框架自带的状态来管理(局部状态),什么情况使用状态管理类库呢?**

其实在历经这么多年的发展, 早已有最佳实践, 现在笔者来总结下:

状态拆分原则:

1. 公共通用数据放状态类库 (redux/vuex), 否则私有数据放框架局部 (react/vue) 中管理

2. 分散虚复用数据放状态类库, 频繁变动的原子级别数据放局部管理

3. 刷新需要持久化的放在 localstorage 中

## React-Hooks

React-Hooks 解决了类组件什么历史问题:

- 状态难以复用(HOC 导致嵌套层级过多)

- 复杂组件难以维护(逻辑分散且生命周期太多)

- this 指向问题

## React 类组件的生命周期

此处贴一张自己画的图

![React 的生命周期](/blog/skills/images/react生命周期.jpg)

## 组件的逻辑复用

如今组件的逻辑复用, 主要有以下几种方式

- Mixin

- HOC

- Render Props

- Hooks

### Mixin 的优缺点

Mixin 作为早期数据复用的方式, 本质是将对象复制到另一个对象; 主要缺点是:

相关依赖：mixin 有可能去依赖其他的 mixin，当我们修改其中一个的时候，可能会影响到其他的 mixin

命名冲突：不同的人在写的时候很有可能会有命名冲突，比如像 handleChange 等类似常见的名字

增加复杂性：当我们一个组件引入过多的 mixin 时，代码逻辑将会非常复杂，因为在不停的引入状态，和我们最初想的每个组件只做单一的功能背道而驰。

### HOC

HOC 优点是不会影响组件内部的状态,但是缺点也有:

需要在原组件上进行包裹和嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这让调试变得非常困难

HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突

### Render Props

`Render Props`灵活性非常高, 扩展性也很强;但是本身的缺点就是太容易造成“嵌套地狱”

### Hooks

Hooks 可以算是终级解决方案了, 解决了上面的一系列问题

## 为什么要引入 Redux

`Redux` 设计理念: 使用简单数组和对象来表示状态, 使用对象来描述状态的改变, 状态的改变逻辑必须是纯函数, 规范了状态管理的思想:

- Redux 三个特点: 单一数据源, 所有数据都是只读的(只能通过 dispath('name',action)来触发), 处理 action 只是新生成对象而不修改原状态

- 注定了 Redux 的数据可靠性, 可测试性, 无副作用, 数据的来源是清晰的, 数据的修改也能追溯

- 而 set/get 的状态管理混乱, 无数据可靠性(不清楚 set 是否会覆盖其他的对象), 无法追溯数据来源(直接 get 太混乱, 导致复用性差), 不便于测试
