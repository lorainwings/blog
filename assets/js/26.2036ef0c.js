(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{404:function(v,_,t){"use strict";t.r(_);var a=t(27),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"http-协议备忘录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-协议备忘录"}},[v._v("#")]),v._v(" HTTP 协议备忘录")]),v._v(" "),t("p",[v._v("本文用于归纳自己所学的 HTTP 知识, HTTP 协议的知识众多, 平时的点点滴滴的积累最终就能分解并吸收这些内容, 因此也是出于这个目的")]),v._v(" "),t("h2",{attrs:{id:"常见状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见状态码"}},[v._v("#")]),v._v(" 常见状态码")]),v._v(" "),t("p",[v._v("100 Continue：上传大文件前使用")]),v._v(" "),t("p",[v._v("101 Switch Protocols：协议升级使用")]),v._v(" "),t("p",[v._v("102 Processing：服务器已经收到并正在处理请求，但无响应可用")]),v._v(" "),t("p",[v._v("200 OK：成功返回响应")]),v._v(" "),t("p",[v._v("201 Created：有新资源在服务器端被成功创建")]),v._v(" "),t("p",[v._v("202 Accepted：服务器接受并开始处理请求，但请求未处理完成")]),v._v(" "),t("p",[v._v("206 Partial Content：使用 range 协议时返回部分响应内容时的响")]),v._v(" "),t("p",[v._v("300：是一个特殊的重定向状态码，会返回一个有多个链接选项的页面，由用户自行选择")]),v._v(" "),t("p",[v._v("301: 永久重定向")]),v._v(" "),t("p",[v._v("302: 临时重定向")]),v._v(" "),t("p",[v._v("303：类似于 302，重定向后的请求方法改为 GET 方法")]),v._v(" "),t("p",[v._v("304：是一个特殊的重定向状态码，服务端验证过期缓存有效后，要求客户端使用该缓存")]),v._v(" "),t("p",[v._v("307：类似于 302，含义比 302 更明确，重定向后请求的方法和实体不允许变动")]),v._v(" "),t("p",[v._v("308：类似于 301，代表永久重定向，重定向后请求的方法和实体不允许变动")]),v._v(" "),t("p",[v._v("400 Bad Request：服务器认为客户端出现了错误，但不明确，一般是 HTTP 请求格式错误")]),v._v(" "),t("p",[v._v("401 Unauthorized：用户认证信息确实或者不正确")]),v._v(" "),t("p",[v._v("403 Forbidden：服务器理解请求的含义，但没有权限执行")]),v._v(" "),t("p",[v._v("404 Not Found：服务器没有找到对应的资源")]),v._v(" "),t("p",[v._v("405 请求方法不支持")]),v._v(" "),t("p",[v._v("407 Proxy Authentication Required：对需要经由代理的请求，认证信息未通过代理服务器的验证")]),v._v(" "),t("p",[v._v("408 Request Timeout：服务器接收请求超时")]),v._v(" "),t("p",[v._v("500 Internal Server Error：服务器内部错误，且不属于以下错误类型")]),v._v(" "),t("p",[v._v("502 Bad Gateway：代理服务器无法获取到合法响应")]),v._v(" "),t("p",[v._v("503 Service Unavailable：服务器资源尚未准备好处理当前请求")]),v._v(" "),t("p",[v._v("505 HTTP Version Not Supported：请求使用的 HTTP 协议版本不支持")]),v._v(" "),t("h2",{attrs:{id:"get-和-post-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[v._v("#")]),v._v(" GET 和 POST 的区别")]),v._v(" "),t("p",[v._v("主要是以下区别")]),v._v(" "),t("h3",{attrs:{id:"get-的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-的特点"}},[v._v("#")]),v._v(" GET 的特点")]),v._v(" "),t("p",[v._v("GET 请求参数放在 URL, 安全性较于 POST 略差, 且 URL 的参数长度在各个浏览器的实现中有最大限制(chrome4K), 请求能被缓存, 可以保存在浏览器历史记录中,也可以置于收藏夹中, 这种请求是无副作用的, 也就是幂等的, 常用于向服务器获取数据")]),v._v(" "),t("h3",{attrs:{id:"post-的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#post-的特点"}},[v._v("#")]),v._v(" POST 的特点")]),v._v(" "),t("p",[v._v("POST 请求的参数是放在 body 中的, 参数可以是任意的类型, 无大小限制, 安全性比 GET 好,请求无法被缓存, 也无法保存在收藏夹; 这样的请求是有副作用的, 也就是非幂等的, 用途广泛, 可以修改服务器的数据")]),v._v(" "),t("h2",{attrs:{id:"tcp-的链接建立"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的链接建立"}},[v._v("#")]),v._v(" TCP 的链接建立")]),v._v(" "),t("p",[v._v("TCP 通过三次握手建立连接, 通过四次挥手断开连接")]),v._v(" "),t("h3",{attrs:{id:"三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("概念")]),v._v(" "),t("p",[v._v("TCP(Transmission Control Protocol)传输控制协议")])]),v._v(" "),t("p",[v._v("TCP 是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接：")]),v._v(" "),t("p",[v._v("位码即 tcp 标志位，有 6 种标示：")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("SYN(synchronous 建立联机)")])]),v._v(" "),t("li",[t("code",[v._v("ACK(acknowledgement 确认)")])]),v._v(" "),t("li",[t("code",[v._v("PSH(push 传送)")])]),v._v(" "),t("li",[t("code",[v._v("FIN(finish 结束)")])]),v._v(" "),t("li",[t("code",[v._v("RST(reset 重置)")])]),v._v(" "),t("li",[t("code",[v._v("URG(urgent 紧急)")])]),v._v(" "),t("li",[t("code",[v._v("Sequence number(顺序号码)")])]),v._v(" "),t("li",[t("code",[v._v("Acknowledge number(确认号码)")])])]),v._v(" "),t("p",[v._v("第一次握手：主机 A 发送位码为 syn ＝ 1，随机产生 seq number=X(1234567) 的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机；")]),v._v(" "),t("p",[v._v("第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number=(主机 A 的 seq+1)，syn=1，ack=1，随机产生 seq=7654321 的包；")]),v._v(" "),t("p",[v._v("第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1，以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1)，ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。")]),v._v(" "),t("h3",{attrs:{id:"四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[v._v("#")]),v._v(" 四次挥手")]),v._v(" "),t("p",[t("img",{attrs:{src:"/blog/skills/images/four-handshake.jpg",alt:"四次挥手"}})]),v._v(" "),t("p",[v._v("第一次挥手: 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)")]),v._v(" "),t("p",[v._v("第二次挥手: 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)")]),v._v(" "),t("p",[v._v("第三次挥手: 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)")]),v._v(" "),t("p",[v._v("第四次挥手: 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)")]),v._v(" "),t("h2",{attrs:{id:"ssl-tls-的链接建立"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls-的链接建立"}},[v._v("#")]),v._v(" SSL/TLS 的链接建立")]),v._v(" "),t("p",[t("img",{attrs:{src:"/blog/skills/images/SSL-shake.webp",alt:"SSL/TLS的握手"}})]),v._v(" "),t("p",[v._v("SSL/TLS 协议建立的详细流程：")]),v._v(" "),t("h3",{attrs:{id:"clienthello"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clienthello"}},[v._v("#")]),v._v(" ClientHello")]),v._v(" "),t("p",[v._v("首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。")]),v._v(" "),t("p",[v._v("在这一步，客户端主要向服务器发送以下信息：")]),v._v(" "),t("p",[v._v("（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。")]),v._v(" "),t("p",[v._v("（2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。")]),v._v(" "),t("p",[v._v("（3）客户端支持的密码套件列表，如 RSA 加密算法。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("密码套件")]),v._v(" "),t("p",[v._v("密码套件由密钥交换算法, 数据加密算法, 消息验证算法组成")])]),v._v(" "),t("h3",{attrs:{id:"severhello"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#severhello"}},[v._v("#")]),v._v(" SeverHello")]),v._v(" "),t("p",[v._v("服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：")]),v._v(" "),t("p",[v._v("（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。")]),v._v(" "),t("p",[v._v("（2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。")]),v._v(" "),t("p",[v._v("（3）确认的密码套件列表，如 RSA 加密算法。")]),v._v(" "),t("p",[v._v("（4）服务器的数字证书。")]),v._v(" "),t("h3",{attrs:{id:"客户端回应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客户端回应"}},[v._v("#")]),v._v(" 客户端回应")]),v._v(" "),t("p",[v._v("客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。")]),v._v(" "),t("p",[v._v("如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：")]),v._v(" "),t("p",[v._v("（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。")]),v._v(" "),t("p",[v._v("（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),v._v(" "),t("p",[v._v("（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。")]),v._v(" "),t("p",[v._v("上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。")]),v._v(" "),t("h3",{attrs:{id:"服务器的最后回应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务器的最后回应"}},[v._v("#")]),v._v(" 服务器的最后回应")]),v._v(" "),t("p",[v._v("服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：")]),v._v(" "),t("p",[v._v("（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),v._v(" "),t("p",[v._v("（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。")]),v._v(" "),t("p",[v._v("至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。")]),v._v(" "),t("h2",{attrs:{id:"http2-的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http2-的特点"}},[v._v("#")]),v._v(" HTTP2 的特点")]),v._v(" "),t("p",[v._v("HTTP2 解决了很多 HTTP1 的问题, 主要表现以下几个方面")]),v._v(" "),t("ul",[t("li",[v._v("头部压缩")])]),v._v(" "),t("p",[v._v("解决了 HTTP1 中的头部无法压缩的问题, 头部压缩采用 HPACK 算法, 间接提高传输速度")]),v._v(" "),t("ul",[t("li",[v._v("二进制格式")])]),v._v(" "),t("p",[v._v("头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧")]),v._v(" "),t("ul",[t("li",[v._v("数据流优先级")])]),v._v(" "),t("p",[v._v("客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求")]),v._v(" "),t("ul",[t("li",[v._v("多路复用")])]),v._v(" "),t("p",[v._v("HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应")]),v._v(" "),t("ul",[t("li",[v._v("服务器推送")])]),v._v(" "),t("p",[v._v("HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息")]),v._v(" "),t("h2",{attrs:{id:"http3-的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http3-的特点"}},[v._v("#")]),v._v(" HTTP3 的特点")]),v._v(" "),t("p",[v._v("HTTP2 虽然解决了很多历史遗留问题, 但是最致命的还是一旦丢包就会导致 TCP 的重传\n多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。\n所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来")]),v._v(" "),t("ul",[t("li",[v._v("底层传输协议 QUIC")])]),v._v(" "),t("p",[v._v("HTTP/3 把 HTTP 下层的 TCP 协议改成了 QUIC 协议, 它是基于 UDP 的一种协议,\n有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。")]),v._v(" "),t("ul",[t("li",[v._v("加密协议升级为 TLS1.3")])]),v._v(" "),t("p",[v._v("TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPac")]),v._v(" "),t("ul",[t("li",[v._v("握手次数变为 3 次")])]),v._v(" "),t("p",[v._v("HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数")]),v._v(" "),t("h2",{attrs:{id:"tcp-和-udp-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp-的区别"}},[v._v("#")]),v._v(" TCP 和 UDP 的区别")]),v._v(" "),t("p",[v._v("TCP 和 UDP 都是传输层的协议，但二者有着截然不同的基因。")]),v._v(" "),t("h3",{attrs:{id:"tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),t("ul",[t("li",[v._v("面向连接")]),v._v(" "),t("li",[v._v("面向字节流")]),v._v(" "),t("li",[v._v("有状态")]),v._v(" "),t("li",[v._v("保证可靠交付")]),v._v(" "),t("li",[v._v("具备拥塞控制")]),v._v(" "),t("li",[v._v("点对点传播")]),v._v(" "),t("li",[v._v("有序")])]),v._v(" "),t("h3",{attrs:{id:"udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[v._v("#")]),v._v(" UDP")]),v._v(" "),t("ul",[t("li",[v._v("无连接")]),v._v(" "),t("li",[v._v("面向数据报")]),v._v(" "),t("li",[v._v("无状态")]),v._v(" "),t("li",[v._v("不保证可靠交付")]),v._v(" "),t("li",[v._v("不具备拥塞控制")]),v._v(" "),t("li",[v._v("广播、多播")]),v._v(" "),t("li",[v._v("无序")])])])}),[],!1,null,null,null);_.default=e.exports}}]);