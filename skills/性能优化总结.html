<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>性能优化总结 | Lorain&#39;s Diary</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/blog/base/hd-img.jpg">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/base/hd-img.jpg">
    <meta name="description" content="山中樗栎年年在 & 看尽西风木槿花">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/blog/assets/css/0.styles.4a9580f2.css" as="style"><link rel="preload" href="/blog/assets/js/app.339d3b6d.js" as="script"><link rel="preload" href="/blog/assets/js/3.8c44ca0e.js" as="script"><link rel="preload" href="/blog/assets/js/44.00357a70.js" as="script"><link rel="preload" href="/blog/assets/js/4.57980df9.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.930d1339.js"><link rel="prefetch" href="/blog/assets/js/11.cdeb8098.js"><link rel="prefetch" href="/blog/assets/js/12.c8cde42b.js"><link rel="prefetch" href="/blog/assets/js/13.a1373108.js"><link rel="prefetch" href="/blog/assets/js/14.1f75dcec.js"><link rel="prefetch" href="/blog/assets/js/15.6e02fab8.js"><link rel="prefetch" href="/blog/assets/js/16.87b6dc9c.js"><link rel="prefetch" href="/blog/assets/js/17.45db52d8.js"><link rel="prefetch" href="/blog/assets/js/18.5f9597d2.js"><link rel="prefetch" href="/blog/assets/js/19.b4ea0dfc.js"><link rel="prefetch" href="/blog/assets/js/20.7f19d52d.js"><link rel="prefetch" href="/blog/assets/js/21.d8589558.js"><link rel="prefetch" href="/blog/assets/js/22.f566dc38.js"><link rel="prefetch" href="/blog/assets/js/23.b69d67c8.js"><link rel="prefetch" href="/blog/assets/js/24.643b50bd.js"><link rel="prefetch" href="/blog/assets/js/25.31cd7e03.js"><link rel="prefetch" href="/blog/assets/js/26.e8823c82.js"><link rel="prefetch" href="/blog/assets/js/27.a7430202.js"><link rel="prefetch" href="/blog/assets/js/28.d8ebaaa5.js"><link rel="prefetch" href="/blog/assets/js/29.8ea743b9.js"><link rel="prefetch" href="/blog/assets/js/30.b41724ca.js"><link rel="prefetch" href="/blog/assets/js/31.ec1b289b.js"><link rel="prefetch" href="/blog/assets/js/32.9b6fe64e.js"><link rel="prefetch" href="/blog/assets/js/33.4259a063.js"><link rel="prefetch" href="/blog/assets/js/34.4e487b39.js"><link rel="prefetch" href="/blog/assets/js/35.5844e768.js"><link rel="prefetch" href="/blog/assets/js/36.cd999bec.js"><link rel="prefetch" href="/blog/assets/js/37.3d9a9f24.js"><link rel="prefetch" href="/blog/assets/js/38.e4fa97e3.js"><link rel="prefetch" href="/blog/assets/js/39.8ba92439.js"><link rel="prefetch" href="/blog/assets/js/40.3e0a8f49.js"><link rel="prefetch" href="/blog/assets/js/41.55113ca5.js"><link rel="prefetch" href="/blog/assets/js/42.5668885f.js"><link rel="prefetch" href="/blog/assets/js/43.94613343.js"><link rel="prefetch" href="/blog/assets/js/45.555be71a.js"><link rel="prefetch" href="/blog/assets/js/46.03a26959.js"><link rel="prefetch" href="/blog/assets/js/47.b29d5306.js"><link rel="prefetch" href="/blog/assets/js/48.cd893ec3.js"><link rel="prefetch" href="/blog/assets/js/49.12210cfc.js"><link rel="prefetch" href="/blog/assets/js/5.5d055cab.js"><link rel="prefetch" href="/blog/assets/js/50.ddcb3929.js"><link rel="prefetch" href="/blog/assets/js/51.ec0a7d07.js"><link rel="prefetch" href="/blog/assets/js/52.73a630cf.js"><link rel="prefetch" href="/blog/assets/js/53.989d0b51.js"><link rel="prefetch" href="/blog/assets/js/6.5cf5829a.js"><link rel="prefetch" href="/blog/assets/js/7.46c43574.js"><link rel="prefetch" href="/blog/assets/js/8.97b71141.js"><link rel="prefetch" href="/blog/assets/js/9.5a3cc726.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.8f04fa7f.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.4a9580f2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Lorain's Diary</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/skills/" class="nav-link router-link-active">
  📜前端技术
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  📊计算机基础
</a></div><div class="nav-item"><a href="/blog/life/" class="nav-link">
  🍀其他记录
</a></div><div class="nav-item"><a href="https://github.com/lorainwings" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ⭐️Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/skills/" class="nav-link router-link-active">
  📜前端技术
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  📊计算机基础
</a></div><div class="nav-item"><a href="/blog/life/" class="nav-link">
  🍀其他记录
</a></div><div class="nav-item"><a href="https://github.com/lorainwings" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ⭐️Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS语言基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>H5及框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>安全及性能优化</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/浏览器缓存.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/blog/skills/前端安全防范.html" class="sidebar-link">前端安全防范</a></li><li><a href="/blog/skills/Web性能优化.html" class="sidebar-link">Web 性能优化</a></li><li><a href="/blog/skills/性能优化总结.html" class="active sidebar-link">性能优化总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#什么是-web-性能优化" class="sidebar-link">什么是 Web 性能优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#为什么需要性能优化" class="sidebar-link">为什么需要性能优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#优化步骤" class="sidebar-link">优化步骤</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#一、图片优化" class="sidebar-link">一、图片优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#二、html-优化" class="sidebar-link">二、HTML 优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#三、css-优化" class="sidebar-link">三、CSS 优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#四、js-优化" class="sidebar-link">四、JS 优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#五、webpack-优化" class="sidebar-link">五、Webpack 优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#六、使用缓存" class="sidebar-link">六、使用缓存</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#七、浏览器的渲染过程" class="sidebar-link">七、浏览器的渲染过程</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#八、渲染优化" class="sidebar-link">八、渲染优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#九、加载优化" class="sidebar-link">九、加载优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#十、接口优化" class="sidebar-link">十、接口优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#十一、webview-优化" class="sidebar-link">十一、WebView 优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#十一、混合式-app-rn-weex" class="sidebar-link">十一、混合式 APP(RN/Weex)</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#十二、cdn-优化" class="sidebar-link">十二、CDN 优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#十三、dns-优化" class="sidebar-link">十三、DNS 优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#十四、http-优化" class="sidebar-link">十四、HTTP 优化</a></li><li class="sidebar-sub-header"><a href="/blog/skills/性能优化总结.html#十五、性能优化指标" class="sidebar-link">十五、性能优化指标</a></li></ul></li><li><a href="/blog/skills/前端监控及上报.html" class="sidebar-link">前端监控及上报</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>服务端入门</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="性能优化总结"><a href="#性能优化总结" class="header-anchor">#</a> 性能优化总结</h1> <h2 id="什么是-web-性能优化"><a href="#什么是-web-性能优化" class="header-anchor">#</a> 什么是 Web 性能优化</h2> <p>前端性能优化的目的: 让用户访问网站开始到页面完整展示出来的过程中, 通过各种优化策略和优化方法, 让页面加载的更快, 让用户操作响应更加及时, 给用户带来更好的用户体验</p> <h2 id="为什么需要性能优化"><a href="#为什么需要性能优化" class="header-anchor">#</a> 为什么需要性能优化</h2> <p>研究表明, 网页性能差直接加速产品的衰败, 也影响网站收入(广告), 因此我们需要提升 Web 性能从而提升用户体验, 公司营收等</p> <h2 id="优化步骤"><a href="#优化步骤" class="header-anchor">#</a> 优化步骤</h2> <p>以下笔者来详述所有常见的优化手段</p> <h2 id="一、图片优化"><a href="#一、图片优化" class="header-anchor">#</a> 一、图片优化</h2> <h3 id="图片格式选取"><a href="#图片格式选取" class="header-anchor">#</a> 图片格式选取</h3> <p>JPEG(JPG/JPE): 有损压缩格式, 不支持透明度, 体积占用不大, 颜色细节质量不高, 颜色丰富, 通常网页大图(bannber / 轮播)等需要使用</p> <p>PNG(PNG-8/PNG24): 无损压缩格式, 体积占用大, 细节表现好, 通常用于图标 / LOGO 等</p> <p>GIF: 不支持半透明, 支持全透明, 通常用于动画图标</p> <p>WEBP: Google 开源的图像格式, 无损的 WEBP 比 PNG 小 26%, 有损 WEBP 比 JPEG 小 25-34%, 比 GIF 有更好的动画, 但是兼容性不好, 需要做 Hack 处理</p> <h3 id="图片压缩"><a href="#图片压缩" class="header-anchor">#</a> 图片压缩</h3> <p>在实际的使用中, 必须对图片进行压缩, 常用以下工具进行压缩, 可以在本地压缩后上传至 CDN, 也可以在<code>Node</code>服务端使用在线处理:</p> <ul><li>在线压缩 TinyPng(TinyJpg)</li> <li>JPG 压缩工具: Jpegtran</li> <li>PNG 压缩工具: node-pngquant-native</li> <li>GIF 压缩工具: Gifsicle</li></ul> <h3 id="响应式图片"><a href="#响应式图片" class="header-anchor">#</a> 响应式图片</h3> <p>不同的网络环境, 应该加载不同尺寸和像素的图片, 通过请求不同的 URL 参数</p> <p><code>httP://img.xxx.com/images/q100x100/c2exas....</code> 对应的图片是 100x100</p> <p>实现方式:</p> <ol><li><p>通过 JS 读取窗口大小, 选择合适的图片</p></li> <li><p>通过媒体查询</p></li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 640px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token selector">.img_640</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 640px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>通过 H5 的新属性<code>srcset</code></li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>img-320w<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><h3 id="逐步加载图片"><a href="#逐步加载图片" class="header-anchor">#</a> 逐步加载图片</h3> <ul><li><p>使用统一占位符</p></li> <li><p>使用<code>LQIP</code>(低质量图像占位符)</p> <p>安装: <code>npm install lqip</code>, 使用<code>lqip-loader</code>来引入</p></li> <li><p>使用<code>SQIP</code>(基于 SVG 的图像占位符)</p> <p>安装: <code>npm install sqip</code></p></li></ul> <h3 id="图片降级方案"><a href="#图片降级方案" class="header-anchor">#</a> 图片降级方案</h3> <ul><li>Web Font 代替图片</li> <li>使用 Data URI 代替图片</li> <li>采用雪碧图（image spriting）</li></ul> <h2 id="二、html-优化"><a href="#二、html-优化" class="header-anchor">#</a> 二、HTML 优化</h2> <ul><li><p>减少 HTML 的嵌套， 减少 DOM 的节点数</p></li> <li><p>压缩 HTML，删除不必要的字符</p></li></ul> <p>可以使用构建工具的插件<code>html-webpack-plugin</code></p> <ul><li>HTM 的结构优化</li></ul> <p><code>CSS</code>样式尽量放页面的头部, <code>JS引用放在HTML底部</code></p> <p>CSS 加载不会阻塞 DOM Tree 的解析, 但是会阻塞 DOM Tree 的渲染, 也会阻塞后面 JS 的执行。因此 body 元素之前， 可以确保在文档中解析了所有 CSS 样式， 从而减少了浏览器必须重排文档的次数。如果放在底部， 就需要等待最后一个 css 文件下载完成， 出现白屏，影响用户体验</p> <p>JS 放在底部是防止加载、解析、执行对阻塞页面后续元素的正常渲染</p> <ul><li>设置 favicon.ico</li></ul> <p>网站不设置 favicon.ico，控制台会报错，设置的优点是更便于用户对品牌的记忆</p> <ul><li>增加网页的骨架屏</li></ul> <h2 id="三、css-优化"><a href="#三、css-优化" class="header-anchor">#</a> 三、CSS 优化</h2> <ul><li>避免使用通配符*和类正则属性选择器</li> <li>避免使用类的多层级和装饰写法: div#elem.view ul li span{}</li> <li>避免使用占用过多 CPU 和内存的属性: <code>text-indent: -9999px</code></li> <li>关注可继承的 CSS 属性, 避免重复定义相同的属性</li> <li>避免使用 table 布局/float 布局, 一个 td 会导致整个回流</li> <li>使用外链 css(CDN 部署),避免使用@import(阻塞 css 文件加载)</li> <li>CSS 文件压缩</li> <li>字体部署在 CDN, 或者将字体以 base64 保存在 css 中并通过 localstorage 缓存</li> <li>Google 使用国内托管</li> <li>CSS 复杂动画应该尽量将该元素脱离文档流, 否则会引起元素以后的所有元素频繁的回流</li> <li>合理开启 GPU 加速(opacity/will-change/transform/filters), 过多的使用会导致内存占用大, 抗锯齿无效</li></ul> <h2 id="四、js-优化"><a href="#四、js-优化" class="header-anchor">#</a> 四、JS 优化</h2> <h3 id="js-代码优化"><a href="#js-代码优化" class="header-anchor">#</a> JS 代码优化</h3> <ul><li>JS 文件放在<body>底部</body></li> <li>使用节流和防抖</li> <li>使用事件委托</li> <li>避免使用 eval, 太耗性能</li> <li>避免函数嵌套定义, 会导致多次预编译</li> <li>JS 函数的参数类型尽量一致,V8 会调用 <code>turboFan</code> 进行机器码编译优化</li></ul> <h3 id="js-的动画优化"><a href="#js-的动画优化" class="header-anchor">#</a> JS 的动画优化</h3> <ul><li>避免添加大量 JS 动画</li> <li>使用<code>requestAnimationFrame</code>代替<code>setTimeout</code>和<code>setInterval</code></li></ul> <p><code>requestAnimationFrame</code>告诉浏览器在下次重绘前执行, 而<code>setTimeout</code>和<code>setInterval</code>无法保证回调的执行时机</p> <ul><li>动画最好使用 canvas</li> <li>尽量使用 CSS3 动画方案</li></ul> <h3 id="js-对-dom-的操作优化"><a href="#js-对-dom-的操作优化" class="header-anchor">#</a> JS 对 DOM 的操作优化</h3> <ul><li>防止频繁的操作 DOM, 尽量批量化操作</li> <li>将 DOM 离线再进行大量操作</li> <li>避免触发同步布局事件</li></ul> <p>(offset|client|scroll)(Top|Left|Width|Height 的获取都应该缓存起来</p> <h2 id="五、webpack-优化"><a href="#五、webpack-优化" class="header-anchor">#</a> 五、Webpack 优化</h2> <ul><li>依赖包优化(选用相同功能的小库)</li> <li>缩小文件查询时间: (resolve.extension / resolve.mainFields / resolve.modules / resolve.alias)</li> <li>Loader 优化(babel 的 cacheDirectory:true / include / exclude / module.noParse)</li> <li>HappyPack 多进程打包 / hardSourceWebpackPlugin 设置中间模块缓存 / TerserWebpackPlugin / ingorePlugin / Dll 动态链接库 &amp; DllReference</li> <li>TreeShaking / Scope hosting</li> <li>压缩 CSS(optimize-css-assets-webpack-plugin / mini-css-extract-plugin)</li> <li>分包按需加载(splitChunks.cacheGroup)</li> <li>long term cache (固化 js 的 chunkhash / 固化 css 的 contenthash / 固化 chunkId(optimize.chunkIds: 'hashd') / 固化 moduleIds(optimize.moduleIds:'name') / 按需加载模块使用魔法字符串'webpackChunkName' / 提取 webpack 的 runtime 代码)</li></ul> <h2 id="六、使用缓存"><a href="#六、使用缓存" class="header-anchor">#</a> 六、使用缓存</h2> <ul><li>memory cache</li> <li>service worker</li> <li>disk cache</li> <li>push cache（一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放， 同一个 h2 连接可以共享）</li></ul> <h2 id="七、浏览器的渲染过程"><a href="#七、浏览器的渲染过程" class="header-anchor">#</a> 七、浏览器的渲染过程</h2> <ol><li>浏览器解析 HTML，生成 DOM Tree</li> <li>浏览器解析 CSS, 生成 CSSOM Tree</li> <li>浏览器将 DOM Tree 和 CSSOM Tree 合成渲染树</li> <li>布局: 根据生成的 Render Tree, 进行回流, 计算出每个节点的几何位置</li> <li>绘制: 根据渲染树和回流得到几何信息,得到每个节点的绝对像素,并生成图层</li> <li>CPU 将默认图层和复合图层输入到 GPU 进行合成, 最终的到了页面并展示</li></ol> <h2 id="八、渲染优化"><a href="#八、渲染优化" class="header-anchor">#</a> 八、渲染优化</h2> <ul><li><p>服务端渲染</p> <p>包括后端同步渲染、同构直出、BigPipe</p></li> <li><p>客户端渲染</p> <p>JS 渲染：静态化、前后端分离、单页面应用
WebApp： React、 Vue、Angular、PWA
原生 APP： IOS、Android
HybridApp： PhoneGap、Appcan
跨平台开发: RN、Flutter、 小程序</p></li></ul> <h3 id="预渲染"><a href="#预渲染" class="header-anchor">#</a> 预渲染</h3> <p>同构方案集合 CSR 与 SSR 的优点，可以适用于大部分业务场景。但由于在同构的系统架构中，连接前后端的 Node 中间层处于核心链路，系统可用性的瓶颈就依赖于 Node ，一旦作为短板的 Node 挂了，整个服务都不可用</p> <p>一般的场景,使用预渲染即可, 使用 webpack 插件<code>prerender-spa-plugin</code></p> <p>缺点:</p> <ol><li>预渲染只是快照页面, 不适合频繁变动页面</li> <li>设置路由多, 构建时间增长</li></ol> <h3 id="同构直出"><a href="#同构直出" class="header-anchor">#</a> 同构直出</h3> <p>降低首屏渲染时间, 利于 SEO, 直接上线 2 个版本, 利于灾备</p> <ul><li>next.js 服务端渲染 React 组件框架</li> <li>gatsbyjs: 服务端 React 渲染框架</li> <li>nuxt.js 服务端渲染 Vue 框架</li></ul> <h3 id="关于渲染的技术选型"><a href="#关于渲染的技术选型" class="header-anchor">#</a> 关于渲染的技术选型</h3> <ul><li><p>依赖业务形式: 根据业务情况, 选择最佳的业务方案</p></li> <li><p>依赖团队规模: 创业初期选择同步直出 JSP, 后面团队变大可以使用同构直出<code>Node server</code>, 富余人力用 PWA 等等</p></li> <li><p>依赖技术水平: 适合公司的技术水平, 选择合适的技术方案</p></li></ul> <h2 id="九、加载优化"><a href="#九、加载优化" class="header-anchor">#</a> 九、加载优化</h2> <ol><li><strong>懒加载</strong></li></ol> <p>对长网页延迟加载特定元素（图片、JS/CSS），也可以是 JS 的特定函数和方法，优点是减少当前屏无效资源的加载</p> <ol start="2"><li><strong>预加载</strong></li></ol> <p>让浏览器预加载某些资源（图片、js、css、模板），提前加载到本地，后面使用直接从缓存中获取，优点是减少用户后续加载资源的等待时间</p> <blockquote><p>方式一:</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://xxxx<span class="token punctuation">&quot;</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">=&quot;</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>none</span><span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><blockquote><p>方式二:</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
img<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;https://xxxx&quot;</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>方式三:</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 当前页需要的资源 as最高优先级,没有as被看做异步请求 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 其他页需要的资源 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image.png<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 预解析跨域的DNS,避免用来解析当前站 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://xxx.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 预先建立与服务器的连接 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preconnect<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://xxx.com<span class="token punctuation">&quot;</span></span> <span class="token attr-name">crossorigin</span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><ol start="3"><li><strong>预渲染</strong></li></ol> <blockquote><p>优点:</p></blockquote> <p>懒加载组件出来之前, 用户需要时间等待完成; 还有一种预加载的方式是提前渲染, 渲染好后隐藏起来, 用的时候直接展示</p> <blockquote><p>实现方式:</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prerender<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://xxx.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><ol start="4"><li><strong>按需加载</strong></li></ol> <p>可以分为<code>常规按需加载</code>(js 或者其他脚本)、不同 App 按需加载(js-sdk 脚本)、 不同设备按需加载(pc 和 h5 样式)、不同分辨率按需加载(css 媒体查询)</p> <h2 id="十、接口优化"><a href="#十、接口优化" class="header-anchor">#</a> 十、接口优化</h2> <ol><li>接口合并</li></ol> <p>一个页面很多业务接口和依赖的第三方接口统一起来，在部署在集群的接口上统一调用，减少页面请求</p> <ol start="2"><li>接口上 CDN</li></ol> <p>这是基于接口的性能考虑，把不需要实时更新的接口同步到 CDN，等接口内容变更之后自动同步到 CDN 集群上。如果一定时间内未请求到数据，回源站接口请求</p> <ol start="3"><li>接口域名上 CDN</li></ol> <p>增强可用性，稳定性</p> <ol start="4"><li>接口降级</li></ol> <p>电商大促中，核心接口进行降级备用基础接口进行业务实现。例如推荐接口，大促可以直接用运营的编辑数据。防止接口无法使用时，备用垫底备份数据</p> <ol start="5"><li>接口监控</li></ol> <p>不是指服务端的<code>TP99</code>,是指用户实际情况成功和失败的情况， 包括弱网、超时、网络异常、网络切换等</p> <ol start="6"><li>接口缓存</li></ol> <p>包括 ajax 缓存、本地缓存（localstorage）、重发请求（网络切换）</p> <h2 id="十一、webview-优化"><a href="#十一、webview-优化" class="header-anchor">#</a> 十一、WebView 优化</h2> <p>IOS 的 webveiw 分为<code>UIWebview</code>和<code>WKWebview</code>, 后者性能更优,内存占用较前者低,加载速度快,可以直接与 JS 互调函数, 而<code>UIWebview</code>需要第三方库来完善; <code>WKWebview</code>的缺点是不支持自动注入<code>cookie</code>,不支持 POST 参数</p> <p>Android 的系统 webview 分为<code>Webkit Webview</code>和<code>chromium Webview</code>(更优秀), 第三方的 webview 主要有<code>X5内核</code>,速度更快, 兼容性更好, 国内各种手机厂商的碎片化支持更好, 视频播放更加强大</p> <p>因此 IOS 选用<code>WKWebview</code>和 Android 使用<code>X5内核</code></p> <ol><li>使用全局 Webview 优化</li></ol> <p>APP 启动, 默认不初始化浏览器内核, 当创建实例时才启动内核, 大概有 70-700ms 延迟。客户端刚启动就初始化全局 webview， 需要使用时，直接加载内容；但是额外会消耗一些内存</p> <ol start="2"><li>URL 预加载</li></ol> <p>准备和请求页面同步进行，URL load 和动画并行加载</p> <ol start="3"><li>滚动条使用体验</li></ol> <p>模拟 WIFI 下页面加载过程， 让用户感觉变快</p> <ol start="4"><li>JS-SDK 的优化</li></ol> <p>一般来说, 常用有三种方式可以调用 nativeApi, 包括<code>上下文注入</code>、<code>弹窗拦截</code>、<code>URL Scheme</code>等</p> <p>现在可直接使用<code>webkit</code>直接调用</p> <ol start="5"><li>H5 离线包方案</li></ol> <p><img src="/blog/skills/images/offline-frame.png" alt="离线包"></p> <p>首先加载全局包-&gt;判断本地是否安装-&gt;如果安装了直接解包到内存-&gt;如果未安装去线上比对后下载再解包到内存-&gt;webview 加载资源时候直接读取内存中的数据-&gt;内存中存在直接返回-&gt;否则去线上地址取</p> <h2 id="十一、混合式-app-rn-weex"><a href="#十一、混合式-app-rn-weex" class="header-anchor">#</a> 十一、混合式 APP(RN/Weex)</h2> <ol><li>RN 的实现方式</li></ol> <p><img src="/blog/skills/images/hybrid-app.png" alt="混合式App"></p> <p><img src="/blog/skills/images/native-frame.png" alt="底层架构"></p> <p>技术选型: React 技术全家桶可以选用 RN</p> <ol start="2"><li>Flutter 的实现方式</li></ol> <p><img src="/blog/skills/images/flutter-bottom-layer.png" alt="底层架构"></p> <p><img src="/blog/skills/images/bottom-layer-compare.png" alt="底层比较">)</p> <p>学习曲线: 相对比 RN 高,重新学习 Dart 语言</p> <p>性能: Native 性能最好,直接和 <code>Skia(C/C++)</code> 引擎通信,没有 <code>JS Bridge</code> 层</p> <p>选型建议: 考虑性能, 业务面向多终端, APP 团队人员多</p> <h2 id="十二、cdn-优化"><a href="#十二、cdn-优化" class="header-anchor">#</a> 十二、CDN 优化</h2> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <p>避免 Ddos 攻击、高可用性处理高流量和负载、节省流量</p> <h3 id="http-请求流程说明"><a href="#http-请求流程说明" class="header-anchor">#</a> HTTP 请求流程说明</h3> <p>1、用户在浏览器输入要访问的网站域名，向本地 DNS 发起域名解析请求。</p> <p>2、域名解析的请求被发往网站授权 DNS 服务器。</p> <p>3、网站 DNS 服务器解析发现域名已经 CNAME 到了 www.example.com.c.cdnhwc1.com。</p> <p>4、请求被指向 CDN 服务。</p> <p>5、CDN 对域名进行智能解析，将响应速度最快的 CDN 节点 IP 地址返回给本地 DNS。</p> <p>6、用户获取响应速度最快的 CDN 节点 IP 地址。</p> <p>7、浏览器在得到速度最快节点的 IP 地址以后，向 CDN 节点发出访问请求。</p> <p>8、CDN 节点将用户所需资源返回给用户。</p> <h3 id="cdn-缓存"><a href="#cdn-缓存" class="header-anchor">#</a> CDN 缓存</h3> <p>常用建议：</p> <ul><li>HTML：3 分钟</li> <li>JS/CSS: 10 分钟、1 天、30 天</li></ul> <p>CDN 的<code>Nginx</code>中通过设置 expires 字段的时长</p> <h3 id="cdn-灰度发布"><a href="#cdn-灰度发布" class="header-anchor">#</a> CDN 灰度发布</h3> <p>不会区域/地区部分运营商优先发布静态资源, 验证通过后, 再进行全量发布</p> <p>通过设置特殊 VIP 解析至要灰度的城市/运营商</p> <h3 id="cdn-备战"><a href="#cdn-备战" class="header-anchor">#</a> CDN 备战</h3> <p>如果是大促, <code>增加机房带宽</code> / <code>增加运营商流量</code> / <code>CDN 应用缓存时间由 10 分钟设置成 1 小时, 大促后恢复</code></p> <h2 id="十三、dns-优化"><a href="#十三、dns-优化" class="header-anchor">#</a> 十三、DNS 优化</h2> <h3 id="客户端处理"><a href="#客户端处理" class="header-anchor">#</a> 客户端处理</h3> <h4 id="android-中采用-一些-dns-模块-okhttp"><a href="#android-中采用-一些-dns-模块-okhttp" class="header-anchor">#</a> Android 中采用 一些 DNS 模块（okhttp）</h4> <ul><li>支持 H2</li> <li>连接池复用减少延迟</li> <li>支持 GZIP，压缩体积</li> <li>响应缓存可以避免网络重复请求</li> <li>配置了多个 IP 地址， 一个 IP 失败，OKhttp 自动尝试下一个</li></ul> <h4 id="ios-中可以采用自研-dns-模块"><a href="#ios-中可以采用自研-dns-模块" class="header-anchor">#</a> IOS 中可以采用自研 DNS 模块</h4> <ul><li>APP 启动时，缓存所有可能要用到的域名 IP，同时异步处理，客户端无需缓存</li> <li>Cache 中有域名缓存， 直接使用缓存</li> <li>没有缓存则重新向 Http server 申请</li></ul> <h4 id="web-前端中的处理-浏览器有并发数限制-做域名分散-资源分布在多个域名"><a href="#web-前端中的处理-浏览器有并发数限制-做域名分散-资源分布在多个域名" class="header-anchor">#</a> Web 前端中的处理， 浏览器有并发数限制，做域名分散，资源分布在多个域名</h4> <ul><li>Java、php 等 API 接口放在一个域名</li> <li>页面和样式（HTML/JS/CSS）放在一个域名</li> <li>图片（jpg、png、gif）放在一个域名</li></ul> <h2 id="十四、http-优化"><a href="#十四、http-优化" class="header-anchor">#</a> 十四、HTTP 优化</h2> <h3 id="减少-http-请求数"><a href="#减少-http-请求数" class="header-anchor">#</a> 减少 HTTP 请求数</h3> <ul><li>css sprites</li> <li>图片使用 DataURI、Web Font</li> <li>JS/CSS 文件合并</li> <li>JS/CSS 请求 combo</li> <li>接口合并</li> <li>接口存储 localstorage</li> <li>静态资源存储 localstorage</li></ul> <h3 id="减小-cookie-大小"><a href="#减小-cookie-大小" class="header-anchor">#</a> 减小 Cookie 大小</h3> <ul><li>主站首页设置白名单</li> <li>定期删除非白名单 Cookie</li> <li>cookie 设置子域名，防止静态资源挟带 cookie</li> <li>设置合理的过期时长</li></ul> <blockquote><p>cookie 什么时候才会自动携带呢?</p></blockquote> <p><img src="/blog/skills/images/cookie-take.png" alt="cookie"></p> <p>如果满足下面几个条件：</p> <p>1、浏览器端某个 Cookie 的 domain 字段等于 aaa.www.com 或者 www.com</p> <p>2、都是 http 或者 https，或者不同的情况下 Secure 属性为 false</p> <p>3、要发送请求的路径，即上面的 xxxxx 跟浏览器端 Cookie 的 path 属性必须一致，或者是浏览器端 Cookie 的 path 的子目录，比如浏览器端 Cookie 的 path 为/test，那么 xxxxxxx 必须为/test 或者/test/xxxx 等子目录才可以</p> <h3 id="ngix-开启-gzip-压缩"><a href="#ngix-开启-gzip-压缩" class="header-anchor">#</a> Ngix 开启 Gzip 压缩</h3> <p>HTTP 请求头 Accept-Encoding 会将客户端能够理解的内容编码方式——通常是某种压缩算法——进行通知（给服务端）。通过内容协商的方式，服务端会选择一个客户端提议的方式，使用并在响应头 Content-Encoding 中通知客户端该选择。</p> <p>Nginx 配置: nginx.conf 文件增加 <code>gzip on</code></p> <p>Apache 配置: <code>AddOutputFilterByType</code> 和 <code>AddOutputFilter</code></p> <h3 id="开启-https"><a href="#开启-https" class="header-anchor">#</a> 开启 HTTPS</h3> <p>优点: <code>利于SEO</code>和<code>更加安全</code></p> <p>实施步骤:</p> <ol><li><p>购买证书(GoGetSSL / SSLs.com / SSLmate.com)</p></li> <li><p>本地安装测试证书</p></li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code>// 通过HomeBrew安装
brew <span class="token function">install</span> mkcert
// 本地安装根证书
mkcert --insatll
// 本地生成签名
mkcert xxx.com

</code></pre></div><ol start="3"><li>本地 nginx 配置</li></ol> <div class="language-nginx extra-class"><pre class="language-nginx"><code><span class="token keyword">server</span><span class="token punctuation">{</span>
  <span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span><span class="token punctuation">;</span> <span class="token comment">#启用HTTPS</span>
  <span class="token keyword">server_name</span> xxx<span class="token punctuation">.</span>com <span class="token comment">#刚才的签名</span>

  <span class="token keyword">ssl_certificate</span> xxx<span class="token operator">+</span>y<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>
  <span class="token keyword">ssl_certificate_key</span> xxx<span class="token operator">+</span>y<span class="token operator">-</span>key<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="使用-http2"><a href="#使用-http2" class="header-anchor">#</a> 使用 HTTP2</h3> <ul><li>二进制传输</li> <li>多路复用 TCP 连接</li> <li>header 头部压缩</li> <li>服务端推送</li></ul> <p><code>缺点是如果一个TCP包丢失,会导致整个TCP的数据重传</code></p> <ol><li>升级 OpenSSL</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code>openssl version
</code></pre></div><ol start="2"><li>重新编译</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">cd</span> nginx-xxx
./configure --with-http_ssl_module --with-http_v2_module
<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> insatll
</code></pre></div><ol start="3"><li>配置 Nginx 的字段</li></ol> <div class="language-nginx extra-class"><pre class="language-nginx"><code><span class="token keyword">server</span><span class="token punctuation">{</span>
  <span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span> <span class="token comment">#启用http2</span>
  <span class="token keyword">server_name</span> xxx<span class="token punctuation">.</span>com <span class="token comment">#刚才的签名</span>

  <span class="token keyword">ssl_certificate</span> xxx<span class="token operator">+</span>y<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>
  <span class="token keyword">ssl_certificate_key</span> xxx<span class="token operator">+</span>y<span class="token operator">-</span>key<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><ol start="4"><li>验证 HTTP2</li></ol> <p>浏览器下查看有没有小绿锁</p> <ol start="5"><li>查看浏览器请求的快照 protocol 字段 是不是 <code>h2</code></li></ol> <h2 id="十五、性能优化指标"><a href="#十五、性能优化指标" class="header-anchor">#</a> 十五、性能优化指标</h2> <p>每个字段的具体含义这里不展开介绍，具体可以看 W3C 对应文档。</p> <h3 id="性能指标"><a href="#性能指标" class="header-anchor">#</a> 性能指标</h3> <ol><li>DNS 解析耗时: domainLookupEnd - domainLookupStart</li> <li>TCP 连接耗时: connectEnd - connectStart</li> <li>SSL 安全连接耗时: connectEnd - secureConnectionStart</li> <li>网络请求耗时(TTFB): responseStart - requestStart</li> <li>数据传输耗时: responseEnd - responseStart</li> <li>DOM 解析耗时: domInteractive - responseEnd</li> <li>资源加载耗时: loadEventStart - domContentLoadedEventEnd</li> <li>首包时间: responseStart - domainLookupStart</li> <li>首次渲染时间 / 白屏时间: responseEnd - fetchStart</li> <li>首次可交互时间: domInteractive - fetchStart</li> <li>DOM Ready 时间: domContentLoadEventEnd - fetchStart</li> <li>页面完全加载时间: loadEventStart - fetchStart</li></ol> <p>参考文档:</p> <ul><li><a href="https://www.w3.org/TR/navigation-timing/#performancetiming" target="_blank" rel="noopener noreferrer">W3C 性能指标<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">4/4/2021, 2:11:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/skills/Web性能优化.html" class="prev">
        Web 性能优化
      </a></span> <span class="next"><a href="/blog/skills/前端监控及上报.html">
        前端监控及上报
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/blog/assets/js/app.339d3b6d.js" defer></script><script src="/blog/assets/js/3.8c44ca0e.js" defer></script><script src="/blog/assets/js/44.00357a70.js" defer></script><script src="/blog/assets/js/4.57980df9.js" defer></script>
  </body>
</html>
