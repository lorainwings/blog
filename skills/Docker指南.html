<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker 指南 | Lorain&#39;s个人主页</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/blog/base/hd-img.jpg">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="apple-touch-icon" href="/blog/base/hd-img.jpg">
    <meta name="description" content="记录技术&生活">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    <link rel="preload" href="/blog/assets/css/0.styles.579a9854.css" as="style"><link rel="preload" href="/blog/assets/js/app.fb786ebe.js" as="script"><link rel="preload" href="/blog/assets/js/3.ab657a59.js" as="script"><link rel="preload" href="/blog/assets/js/17.5f2beb7f.js" as="script"><link rel="preload" href="/blog/assets/js/4.022282fe.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.57550636.js"><link rel="prefetch" href="/blog/assets/js/11.bb55d292.js"><link rel="prefetch" href="/blog/assets/js/12.1e4a5a90.js"><link rel="prefetch" href="/blog/assets/js/13.a0e2552d.js"><link rel="prefetch" href="/blog/assets/js/14.db5c8151.js"><link rel="prefetch" href="/blog/assets/js/15.a2f176cb.js"><link rel="prefetch" href="/blog/assets/js/16.5298f88a.js"><link rel="prefetch" href="/blog/assets/js/18.e510d28d.js"><link rel="prefetch" href="/blog/assets/js/19.53886023.js"><link rel="prefetch" href="/blog/assets/js/20.63c552fe.js"><link rel="prefetch" href="/blog/assets/js/21.67e51d39.js"><link rel="prefetch" href="/blog/assets/js/22.42eb15fc.js"><link rel="prefetch" href="/blog/assets/js/23.3a3358e3.js"><link rel="prefetch" href="/blog/assets/js/24.e9e2a625.js"><link rel="prefetch" href="/blog/assets/js/25.096364ce.js"><link rel="prefetch" href="/blog/assets/js/26.0ccf51ed.js"><link rel="prefetch" href="/blog/assets/js/27.054a8201.js"><link rel="prefetch" href="/blog/assets/js/28.f04b9341.js"><link rel="prefetch" href="/blog/assets/js/29.c8add927.js"><link rel="prefetch" href="/blog/assets/js/30.1aef2e5e.js"><link rel="prefetch" href="/blog/assets/js/31.1abd6355.js"><link rel="prefetch" href="/blog/assets/js/32.03df97b0.js"><link rel="prefetch" href="/blog/assets/js/33.c00a706c.js"><link rel="prefetch" href="/blog/assets/js/34.2f847376.js"><link rel="prefetch" href="/blog/assets/js/35.63347724.js"><link rel="prefetch" href="/blog/assets/js/36.9fdc020c.js"><link rel="prefetch" href="/blog/assets/js/37.3392c04b.js"><link rel="prefetch" href="/blog/assets/js/38.ade4c9de.js"><link rel="prefetch" href="/blog/assets/js/39.6aec4626.js"><link rel="prefetch" href="/blog/assets/js/40.9c723d93.js"><link rel="prefetch" href="/blog/assets/js/5.904e5833.js"><link rel="prefetch" href="/blog/assets/js/6.2426cfb9.js"><link rel="prefetch" href="/blog/assets/js/7.7194594b.js"><link rel="prefetch" href="/blog/assets/js/8.e15df7e7.js"><link rel="prefetch" href="/blog/assets/js/9.3ff9262b.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.21b1897d.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.579a9854.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Lorain's个人主页</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/skills/" class="nav-link router-link-active">
  技术进阶
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  算法相关
</a></div><div class="nav-item"><a href="/blog/life/" class="nav-link">
  记录生活
</a></div><div class="nav-item"><a href="https://github.com/lorainwings" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/skills/" class="nav-link router-link-active">
  技术进阶
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  算法相关
</a></div><div class="nav-item"><a href="/blog/life/" class="nav-link">
  记录生活
</a></div><div class="nav-item"><a href="https://github.com/lorainwings" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Client &amp; Side</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Build &amp; Tools</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Design &amp; Patterns</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Server &amp; Side</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/Crontab.html" class="sidebar-link">Crontab</a></li><li><a href="/blog/skills/查看日志.html" class="sidebar-link">查看日志</a></li><li><a href="/blog/skills/Docker指南.html" class="active sidebar-link">Docker 指南</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/skills/Docker指南.html#概念-作用-组成" class="sidebar-link">概念 &amp; 作用 &amp; 组成</a></li><li class="sidebar-sub-header"><a href="/blog/skills/Docker指南.html#运行环境" class="sidebar-link">运行环境</a></li><li class="sidebar-sub-header"><a href="/blog/skills/Docker指南.html#操作镜像" class="sidebar-link">操作镜像</a></li><li class="sidebar-sub-header"><a href="/blog/skills/Docker指南.html#使用容器" class="sidebar-link">使用容器</a></li><li class="sidebar-sub-header"><a href="/blog/skills/Docker指南.html#dockerfile" class="sidebar-link">Dockerfile</a></li><li class="sidebar-sub-header"><a href="/blog/skills/Docker指南.html#组合应用" class="sidebar-link">组合应用</a></li></ul></li><li><a href="/blog/skills/DockerForV2ray.html" class="sidebar-link">Docker For V2ray</a></li><li><a href="/blog/skills/Nginx配置浅析.html" class="sidebar-link">Nginx 配置浅析</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="docker-指南"><a href="#docker-指南" class="header-anchor">#</a> Docker 指南</h1> <p>最近重新学习了一遍 docker 相关的概念和知识, 在此记录相关知识点以作为备忘</p> <h2 id="概念-作用-组成"><a href="#概念-作用-组成" class="header-anchor">#</a> 概念 &amp; 作用 &amp; 组成</h2> <h3 id="docker-概念"><a href="#docker-概念" class="header-anchor">#</a> Docker 概念</h3> <div class="language-概念 extra-class"><pre class="language-text"><code>docker是LXC(Linux容器虚拟化)的产物, 为了提升集成环境的部署便利性而生, 将软件打包成标准化单元，以用于开发、交付和部署;
</code></pre></div><h3 id="docker-的作用"><a href="#docker-的作用" class="header-anchor">#</a> Docker 的作用</h3> <ul><li>开发者能够使用 Docker 在本地编写代码并通过容器与其他同事共享他们的工作。</li> <li>他们能够使用 Docker 将编写好的程序推送至测试环境进行自动化测试或是人工测试。</li> <li>当出现 Bugs 时，开发者可以在开发环境中修复它们，并很快的重新部署到测试环境中。</li> <li>在测试完成后，部署装有应用程序的镜像就能完成生产环境的发布。</li></ul> <h3 id="docker-的组成"><a href="#docker-的组成" class="header-anchor">#</a> Docker 的组成</h3> <ul><li>镜像(images)</li> <li>容器(container)</li> <li>网络(network)</li> <li>数据卷(volume)</li></ul> <h2 id="运行环境"><a href="#运行环境" class="header-anchor">#</a> 运行环境</h2> <p>搭建 docker 的运行环境主要包括以下几个部分:</p> <ul><li>安装 docker</li> <li>配 docker 加速镜像源</li></ul> <h3 id="安装-docker"><a href="#安装-docker" class="header-anchor">#</a> 安装 docker</h3> <p>在 Windows 和 Mac 中安装 Docker, 通过下面链接直接安装桌面应用, 非常简单</p> <ul><li><a href="https://store.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener noreferrer">Docker for Windows<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://store.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener noreferrer">Docker for Mac<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p>在 Linux 系统中安装 Docker, 通过下面命令即可</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># CentOS</span>
  <span class="token function">sudo</span> yum <span class="token function">install</span> yum-utils device-mapper-persistent-data lvm2
 
  <span class="token function">sudo</span> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
  <span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce
 
  <span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> docker
  <span class="token function">sudo</span> systemctl start docker
</code></pre></div><div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># Debian</span>
  <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> apt-transport-https ca-certificates <span class="token function">curl</span> gnupg2 software-properties-common
 
  <span class="token function">curl</span> -fsSL https://download.docker.com/linux/debian/gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -
  <span class="token function">sudo</span> add-apt-repository <span class="token string">&quot;deb [arch=amd64] https://download.docker.com/linux/debian  (lsb_release -cs) stable&quot;</span>
  <span class="token function">sudo</span> <span class="token function">apt-get</span> update
  <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce
 
  <span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> docker
  <span class="token function">sudo</span> systemctl start docker
</code></pre></div><h3 id="配置-docker-加速镜像源"><a href="#配置-docker-加速镜像源" class="header-anchor">#</a> 配置 docker 加速镜像源</h3> <p>在 Linux 环境下，通过修改 /etc/docker/daemon.json ( 如果文件不存在，需要自己创建 ), 国内加速镜像源众多, 笔者此处使用了 ustc 和 163 的镜像源</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;registry-mirrors&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;https://hub-mirror.c.163.com&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 Macos 和 Windows 的 desktop 桌面端, 需要打开编辑配置, 如下图加入配置即可</p> <p><img src="http://ww1.sinaimg.cn/large/715b1061ly1gg9b3nuhkyj21ls10oq7r.jpg" alt="docker镜像源配置"></p> <h2 id="操作镜像"><a href="#操作镜像" class="header-anchor">#</a> 操作镜像</h2> <p>一般获取镜像的途径都是从官方的镜像仓库中获得, 镜像仓库类似于(github), 此处记录操作镜像常用的命令</p> <p><strong>获取镜像</strong>: <code>docker pull [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker pull ubuntu
</code></pre></div><p><strong>查看本地镜像</strong>: <code>docker images</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker images
</code></pre></div><p><strong>搜索镜像</strong>: <code>docker search [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker search ubuntu
</code></pre></div><p><strong>查看镜像详细信息</strong>: <code>docker inspect [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker inspect redis:4.0
</code></pre></div><p><strong>删除本地镜像</strong>: <code>docker rmi [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker rmi ubuntu:latest
</code></pre></div><h2 id="使用容器"><a href="#使用容器" class="header-anchor">#</a> 使用容器</h2> <p>容器是基于容器技术所建立和运行的轻量级应用运行环境,在 Docker 中，容器算是最核心的部分, 此处分为以下三部分来记录:</p> <ul><li>操作命令</li> <li>数据管理</li> <li>使用网络</li></ul> <h3 id="操作命令"><a href="#操作命令" class="header-anchor">#</a> 操作命令</h3> <p><strong>创建容器</strong>: <code>docker create [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker create nginx:1.12
</code></pre></div><p><strong>启动容器</strong>: <code>docker start nginx</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker start nginx
</code></pre></div><p><strong>创建并启动</strong>: <code>docker run --name [name] -d [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run --name nginx -d nginx:1.12
</code></pre></div><p><strong>查看容器</strong>: <code>docker ps</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker <span class="token function">ps</span>

<span class="token comment">#查看全部容器</span>
docker <span class="token function">ps</span> -a
</code></pre></div><p><strong>停止容器</strong>: <code>docker stop [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker stop nginx
</code></pre></div><p><strong>删除容器</strong>: <code>docker rm [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 删除未运行的容器</span>
docker <span class="token function">rm</span> nginx

<span class="token comment"># 删除任何状态的容器</span>
docker <span class="token function">rm</span> nginx -f
</code></pre></div><p><strong>进入容器</strong>: <code>docker exec [name/tag/id] [命令]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker <span class="token builtin class-name">exec</span> nginx <span class="token function">more</span> /etc/hostname
</code></pre></div><p><strong>容器开启命令行交互</strong>:</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker <span class="token builtin class-name">exec</span> -it nginx <span class="token function">bash</span>
</code></pre></div><p>上面 -i ( --interactive ) 表示保持我们的输入流，只有使用它才能保证控制台程序能够正确识别我们的命令。而 -t ( --tty ) 表示启用一个伪终端，形成我们与 bash 的交互，如果没有它，我们无法看到 bash 内部的执行结果</p> <p><strong>衔接容器</strong>: <code>docker attach [name/tag/id]</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker attach nginx
</code></pre></div><h3 id="数据管理"><a href="#数据管理" class="header-anchor">#</a> 数据管理</h3> <p>数据管理又分为以下几个部分:</p> <ul><li>挂载方式</li> <li>数据卷操作</li> <li>数据卷容器</li> <li>备份迁移</li></ul> <h4 id="挂载方式"><a href="#挂载方式" class="header-anchor">#</a> 挂载方式</h4> <p>在 docker 中, 为了方便与外面数据传递, docker 基于底层存储实现，提供了三种适用于不同场景的文件系统挂载方式：Bind Mount、Volume 和 Tmpfs Mount。</p> <ul><li>Bind Mount</li></ul> <p>能够直接将宿主操作系统中的目录和文件挂载到容器内的文件系统中，通过指定容器外的路径和容器内的路径，就可以形成挂载映射关系，在容器内外对文件的读写，都是相互可见的。</p> <p><code>使用方式: -v &lt;host-path&gt;:&lt;container-path&gt;</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run -d --name nginx -v /webapp/html:/usr/share/nginx/html nginx:1.12
</code></pre></div><ul><li>Volume</li></ul> <p>也是从宿主操作系统中挂载目录到容器内，只不过这个挂载的目录由 Docker 进行管理，我们只需要指定容器内的目录，不需要关心具体挂载到了宿主操作系统中的哪里。</p> <p><code>使用方式: -v &lt;container-path&gt;</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> docker run -d --name webapp -v /webapp/storage webapp:latest

<span class="token comment"># 如需查看具体挂载信息</span>
docker inspect webapp
</code></pre></div><ul><li>Tmpfs Mount</li></ul> <p>支持挂载系统内存中的一部分到容器的文件系统里，不过由于内存和容器的特征，它的存储并不是持久的，其中的内容会随着容器的停止而消失。</p> <p><code>使用方式: --tmpfs &lt;container-path&gt;</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> docker run -d --name webapp -v /webapp/storage webapp:latest

<span class="token comment"># 如需查看临时文件目录</span>
docker inspect webapp
</code></pre></div><ul><li>Mount</li></ul> <p>在 --mount 中，我们可以通过逗号分隔这种 CSV 格式来定义多个参数。其中，通过 type 我们可以定义挂载类型，其值可以是：bind，volume 或 tmpfs。另外，--mount 选项能够帮助我们实现集群挂载的定义;</p> <p><code>使用方式: --mount &lt;type&gt;</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run -d --name webapp webapp:latest --mount <span class="token string">'type=volume,src=appdata,dst=/webapp/storage,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server&gt;:&lt;nfs-path&gt;'</span> webapp:latest
</code></pre></div><h4 id="数据卷操作"><a href="#数据卷操作" class="header-anchor">#</a> 数据卷操作</h4> <p>数据卷命名: <code>-v &lt;name&gt;:&lt;container-path&gt;</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run -d --name webapp -v appdata:/webapp/storage webapp:latest
</code></pre></div><p>共用数据卷: <code>使用同名的数据卷[name]即可</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run -d --name webapp -v html:/webapp/html webapp:latest
docker run -d --name nginx -v html:/usr/share/nginx/html:ro nginx:1.12
</code></pre></div><p>创建独立数据卷: <code>docker volume create</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker volume create appdata
</code></pre></div><p>查看已创建的数据卷: <code>docker volume ls</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker volume <span class="token function">ls</span>
</code></pre></div><p>删除数据卷: <code>docker volume rm</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker volume <span class="token function">rm</span> appdata

<span class="token comment"># 加上-v参数可以一并删除容器关联的数据卷</span>
docker <span class="token function">rm</span> -v webapp
</code></pre></div><p>删除未引用的数据卷: <code>docker volume prune</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker volume prune -f
</code></pre></div><h4 id="数据卷容器"><a href="#数据卷容器" class="header-anchor">#</a> 数据卷容器</h4> <p>创建数据卷容器的方式很简单，由于不需要容器本身运行，因而我们找个简单的系统镜像都可以完成创建。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker create --name appdata -v /webapp/storage ubuntu
</code></pre></div><p>引用数据卷容器: <code>--volumes-from &lt;name&gt;</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run -d --name webapp --volumes-from appdata webapp:latest
</code></pre></div><h4 id="备份迁移"><a href="#备份迁移" class="header-anchor">#</a> 备份迁移</h4> <p>要备份数据，我们先建立一个临时的容器，将用于备份的目录和要备份的数据卷都挂载到这个容器上</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run --rm --volumes-from appdata -v /backup:/backup ubuntu <span class="token function">tar</span> cvf /backup/backup.tar /webapp/storage
</code></pre></div><p>如果要恢复数据卷中的数据，我们也可以借助临时容器完成</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run --rm --volumes-from appdata -v /backup:/backup ubuntu <span class="token function">tar</span> xvf /backup/backup.tar -C /webapp/storage --strip
</code></pre></div><h3 id="使用网络"><a href="#使用网络" class="header-anchor">#</a> 使用网络</h3> <p>容器使用网络这部分, 笔者将这部分分为以下几个部分来描述:</p> <ul><li>核心组成</li> <li>容器互联</li> <li>暴露端口</li> <li>别名连接</li> <li>创建网络</li> <li>端口映射</li></ul> <h4 id="核心组成"><a href="#核心组成" class="header-anchor">#</a> 核心组成</h4> <p>容器网络实质上也是由 Docker 为应用程序所创造的虚拟环境的一部分，它能让应用从宿主机操作系统的网络环境中独立出来，形成容器自有的网络设备、IP 协议栈、端口套接字、IP 路由表、防火墙等等与网络相关的模块, 容器的网络主要由<code>沙盒</code>和<code>网络</code>以及<code>端点</code>组成</p> <ul><li><strong>沙盒</strong>: 提供了容器的虚拟网络栈</li> <li><strong>网络</strong>: 组成 Docker 内部的虚拟子网</li> <li><strong>端点</strong>: 主要目的是形成一个可以控制的突破封闭的网络环境的出入口</li></ul> <h4 id="容器互联"><a href="#容器互联" class="header-anchor">#</a> 容器互联</h4> <p>要让一个容器连接到另外一个容器，我们可以在容器通过<code>docker create</code>或<code>docker run</code>创建时通过<code>--link</code>选项进行配置</p> <p>例如，这里我们创建一个 MySQL 容器，将运行我们 Web 应用的容器连接到这个 MySQL 容器上，打通两个容器间的网络，实现它们之间的网络互通。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>  docker run -d --name mysql -e <span class="token assign-left variable">MYSQL_RANDOM_ROOT_PASSWORD</span><span class="token operator">=</span>yes mysql
  docker run -d --name webapp --link mysql webapp:latest
</code></pre></div><h4 id="暴露端口"><a href="#暴露端口" class="header-anchor">#</a> 暴露端口</h4> <p>口的暴露可以通过 Docker 镜像进行定义，也可以在容器创建时进行定义。在容器创建时进行定义的方法是借助 --expose 这个选项。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run -d --name mysql -e <span class="token assign-left variable">MYSQL_RANDOM_ROOT_PASSWORD</span><span class="token operator">=</span>yes --expose <span class="token number">13306</span> --expose <span class="token number">23306</span> mysql:5.7
</code></pre></div><p>这里我们为 MySQL 暴露了 13306 和 23306 这两个端口，暴露后我们可以在 docker ps 中看到这两个端口已经成功的打开。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ docker <span class="token function">ps</span> 
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                       NAMES
3c4e645f21d7        mysql:5.7           <span class="token string">&quot;docker-entrypoint.s…&quot;</span>   <span class="token number">4</span> seconds ago       Up <span class="token number">3</span> seconds        <span class="token number">3</span>
</code></pre></div><h4 id="别名连接"><a href="#别名连接" class="header-anchor">#</a> 别名连接</h4> <p>纯粹的通过容器名来打开容器间的网络通道缺乏一定的灵活性，在 Docker 里还支持连接时使用别名来使我们摆脱容器名的限制。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> docker run -d --name webapp --link mysql:database webapp:latest
</code></pre></div><p>在这里，我们使用 <code>--link &lt;name&gt;:&lt;alias&gt;</code> 的形式，连接到 MySQL 容器，并设置它的别名为 database。当我们要在 Web 应用中使用 MySQL 连接时，我们就可以使用 database 来代替连接地址了。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>String url <span class="token operator">=</span> <span class="token string">&quot;jdbc:mysql://database:3306/webapp&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="创建网络"><a href="#创建网络" class="header-anchor">#</a> 创建网络</h4> <p>在 Docker 里，我们也能够创建网络，形成自己定义虚拟子网的目的。</p> <p>docker CLI 里与网络相关的命令都以 docker network 开头，其中创建网络的命令是 <code>docker network create</code>。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> docker network create -d bridge individual
</code></pre></div><p>通过 <code>docker network ls</code> 或是 <code>docker network list</code> 可以查看 Docker 中已经存在的网络。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker network <span class="token function">ls</span>
NETWORK ID          NAME                DRIVER              SCOPE
bc14eb1da66b        bridge              bridge              <span class="token builtin class-name">local</span>
35c3ef1cc27d        individual          bridge              <span class="token builtin class-name">local</span>
</code></pre></div><p>之后在我们创建容器时，可以通过<code>--network</code> 来指定容器所加入的网络，一旦这个参数被指定，容器便不会默认加入到 bridge 这个网络中了 ( 但是仍然可以通过 <code>--network bridge</code> 让其加入 )。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> docker run -d --name mysql -e <span class="token assign-left variable">MYSQL_RANDOM_ROOT_PASSWORD</span><span class="token operator">=</span>yes --network individual mysql:5.7
</code></pre></div><p>查看容器网络: <code>docker inspect</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker inspect mysql
<span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
<span class="token comment">## ......</span>
        <span class="token string">&quot;NetworkSettings&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
<span class="token comment">## ......</span>
            <span class="token string">&quot;Networks&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
                <span class="token string">&quot;individual&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
                    <span class="token string">&quot;IPAMConfig&quot;</span><span class="token builtin class-name">:</span> null,
                    <span class="token string">&quot;Links&quot;</span><span class="token builtin class-name">:</span> null,
                    <span class="token string">&quot;Aliases&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                        <span class="token string">&quot;2ad678e6d110&quot;</span>
                    <span class="token punctuation">]</span>,
                    <span class="token string">&quot;NetworkID&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;35c3ef1cc27d24e15a2b22bdd606dc28e58f0593ead6a57da34a8ed989b1b15d&quot;</span>,
                    <span class="token string">&quot;EndpointID&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;41a2345b913a45c3c5aae258776fcd1be03b812403e249f96b161e50d66595ab&quot;</span>,
                    <span class="token string">&quot;Gateway&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;172.18.0.1&quot;</span>,
                    <span class="token string">&quot;IPAddress&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;172.18.0.2&quot;</span>,
                    <span class="token string">&quot;IPPrefixLen&quot;</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,
                    <span class="token string">&quot;IPv6Gateway&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>,
                    <span class="token string">&quot;GlobalIPv6Address&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>,
                    <span class="token string">&quot;GlobalIPv6PrefixLen&quot;</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
                    <span class="token string">&quot;MacAddress&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;02:42:ac:12:00:02&quot;</span>,
                    <span class="token string">&quot;DriverOpts&quot;</span><span class="token builtin class-name">:</span> null
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
<span class="token comment">## ......</span>
        <span class="token punctuation">}</span>
<span class="token comment">## ......</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><h4 id="端口映射"><a href="#端口映射" class="header-anchor">#</a> 端口映射</h4> <p>要映射端口，我们可以在创建容器时使用<code>-p</code>或者是 <code>--publish</code>选项。</p> <p>端口映射格式: <code>-p &lt;ip&gt;:&lt;host-port&gt;:&lt;container-port&gt;</code></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> docker run -d --name nginx -p <span class="token number">80</span>:80 -p <span class="token number">443</span>:443 nginx:1.12
</code></pre></div><h2 id="dockerfile"><a href="#dockerfile" class="header-anchor">#</a> Dockerfile</h2> <p>Dockerfile 是 Docker 中用于定义镜像自动化构建流程的配置文件, 通过 Dockerfile 我们可以更加清晰、明确的给定 Docker 镜像的制作过程, 文件体积小巧能更加方便实现容器迁移和集群部署</p> <ul><li>Dockerfile 结构</li> <li>常见 Dockerfile 指令</li> <li>Dockerfile 构建</li></ul> <h3 id="dockerfile-结构"><a href="#dockerfile-结构" class="header-anchor">#</a> Dockerfile 结构</h3> <p>如果进行细分，我们可以将 Dockerfile 的指令简单分为五大类。</p> <ul><li>基础指令：用于定义新镜像的基础和性质。</li> <li>控制指令：是指导镜像构建的核心部分，用于描述镜像在构建过程中需要执行的命令。</li> <li>引入指令：用于将外部文件直接引入到构建镜像内部。</li> <li>执行指令：能够为基于镜像所创建的容器，指定在启动时需要执行的脚本或命令。</li> <li>配置指令：对镜像以及基于镜像所创建的容器，可以通过配置指令对其网络、用户等内容进行配置。</li></ul> <h3 id="常见-dockerfile-指令"><a href="#常见-dockerfile-指令" class="header-anchor">#</a> 常见 Dockerfile 指令</h3> <p><strong>FROM</strong>: <code>FROM</code> 指令指定一个基础镜像, 可以使用以下三种形式使用</p> <div class="language-Dockerfile extra-class"><pre class="language-dockerfile"><code><span class="token keyword">FROM</span> &lt;image<span class="token punctuation">&gt;</span> <span class="token punctuation">[</span>AS &lt;name<span class="token punctuation">&gt;</span><span class="token punctuation">]</span>
<span class="token keyword">FROM</span> &lt;image<span class="token punctuation">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">:</span>&lt;tag<span class="token punctuation">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>AS &lt;name<span class="token punctuation">&gt;</span><span class="token punctuation">]</span>
<span class="token keyword">FROM</span> &lt;image<span class="token punctuation">&gt;</span><span class="token punctuation">[</span>@&lt;digest<span class="token punctuation">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>AS &lt;name<span class="token punctuation">&gt;</span><span class="token punctuation">]</span>
</code></pre></div><p><strong>RUN</strong>: <code>RUN</code> 指令之后，我们直接拼接上需要执行的命令，在构建时，Docker 就会执行这些命令，并将它们对文件系统的修改记录下来，形成镜像的变化;</p> <p>主要用来用来指定构建镜像(build image) 过程中执行的命令</p> <div class="language-sh extra-class"><pre class="language-sh"><code>RUN <span class="token operator">&lt;</span>command<span class="token operator">&gt;</span>
RUN <span class="token punctuation">[</span><span class="token string">&quot;executable&quot;</span>, <span class="token string">&quot;param1&quot;</span>, <span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>`
</code></pre></div><p><strong>CMD</strong>: 指定容器运行时(<code>docker run</code>) 默认命令和参数，可以被 <code>docker run *** command</code> 的命令所覆盖</p> <div class="custom-block tip"><p class="custom-block-title">RUN &amp; CMD &amp; ENTRYPOINT 区别:</p> <p><code>RUN</code>不接任何命令, 同时没有<code>ENTRYPOINT</code>指定, 将默认执行 CMD</p> <p><code>RUN</code>不接任何命令, 同时存在<code>ENTRYPOINT</code>和<code>CMD</code>, <code>CMD</code>将作为<code>ENTRYPOINT</code>的参数</p> <p><code>RUN</code>后接 command, 同时存在<code>ENTRYPOINT</code>和<code>CMD</code>, <code>RUN</code>后的参数作为<code>ENTRYPOINT</code>的参数, <code>CMD</code>被忽略</p></div> <div class="language-sh extra-class"><pre class="language-sh"><code>CMD <span class="token punctuation">[</span><span class="token string">&quot;executable&quot;</span>,<span class="token string">&quot;param1&quot;</span>,<span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>
CMD <span class="token punctuation">[</span><span class="token string">&quot;param1&quot;</span>,<span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>
CMD <span class="token builtin class-name">command</span> param1 param2
</code></pre></div><p><strong>ENTRYPOINT</strong>: 容器运行时执行的命令，但是可以接受<code>docker run *** args</code>或者 CMD 提供的参数，一般用于容器配置初始化</p> <div class="language-sh extra-class"><pre class="language-sh"><code>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;executable&quot;</span>, <span class="token string">&quot;param1&quot;</span>, <span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>
ENTRYPOINT <span class="token builtin class-name">command</span> param1 param2
</code></pre></div><p><strong>EXPOSE</strong>: 通过 EXPOSE 指令就可以为镜像指定要暴露的端口。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>EXPOSE <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>port<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>protocol<span class="token operator">&gt;</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><p><strong>VOLUME</strong>: 定义基于此镜像的容器所自动建立的数据卷, 以便于持久化一些数据，比如数据库中存储数据的文件夹就需要单独处理</p> <div class="language-sh extra-class"><pre class="language-sh"><code>VOLUME <span class="token punctuation">[</span><span class="token string">&quot;/data&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>在 VOLUME 指令中定义的目录，在基于新镜像创建容器时，会自动建立为数据卷，不需要我们再单独使用 -v 选项来配置了。</p> <p><strong>COPY &amp; ADD</strong></p> <p>在制作新的镜像的时候，我们可能需要将一些软件配置、程序代码、执行脚本等直接导入到镜像内的文件系统里，使用 <code>COPY</code> 或 ADD 指令能够帮助我们直接从宿主机的文件系统里拷贝内容到镜像里的文件系统中。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>COPY <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">&gt;</span>
ADD <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">&gt;</span>

COPY <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">&quot;&lt;src&gt;&quot;</span>,<span class="token punctuation">..</span>. <span class="token string">&quot;&lt;dest&gt;&quot;</span><span class="token punctuation">]</span>
ADD <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">&quot;&lt;src&gt;&quot;</span>,<span class="token punctuation">..</span>. <span class="token string">&quot;&lt;dest&gt;&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>COPY 与 ADD 指令的定义方式完全一样，需要注意的仅是当我们的目录中存在空格时，可以使用后两种格式避免空格产生歧义。</p> <p>对比 <code>COPY</code> 与 <code>ADD</code>，两者的区别主要在于 <code>ADD</code> 能够支持使用网络端的 <code>URL</code> 地址作为 src 源，并且在源文件被识别为压缩包时，自动进行解压，而 <code>COPY</code> 没有这两个能力。</p> <p>虽然看上去 <code>COPY</code> 能力稍弱，但对于那些不希望源文件被解压或没有网络请求的场景，COPY 指令是个不错的选择。</p> <h3 id="dockerfile-构建"><a href="#dockerfile-构建" class="header-anchor">#</a> Dockerfile 构建</h3> <p>构建镜像的命令为 <code>docker build</code>。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> docker build ./webapp
</code></pre></div><p>如果我们的 Dockerfile 文件路径不在这个目录下，或者有另外的文件名，我们可以通过<code>-f</code>选项单独给出 Dockerfile 文件的路径。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker build -t webapp:latest -f ./webapp/a.Dockerfile ./webapp

<span class="token comment"># 在构建时我们最好总是携带上 -t 选项，用它来指定新生成镜像的名称。</span>
$ <span class="token function">sudo</span> docker build -t webapp:latest ./webapp
</code></pre></div><h2 id="组合应用"><a href="#组合应用" class="header-anchor">#</a> 组合应用</h2> <p>一个完整的应用, 需要用多个 docker, 这个章节来记录如何组建组合应用, 为何阐述清楚, 讲<code>docker compose</code>分为以下几个部分来写:</p> <ul><li>Docker Compose 配置文件</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">7/10/2020, 4:44:45 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/skills/查看日志.html" class="prev">
        查看日志
      </a></span> <span class="next"><a href="/blog/skills/DockerForV2ray.html">
        Docker For V2ray
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/blog/assets/js/app.fb786ebe.js" defer></script><script src="/blog/assets/js/3.ab657a59.js" defer></script><script src="/blog/assets/js/17.5f2beb7f.js" defer></script><script src="/blog/assets/js/4.022282fe.js" defer></script>
  </body>
</html>
