# 正则表达式小知识

经常使用正则表达式, 但是有些细节知识总是没搞清楚, 在看了《JS 正则表达式》后一些知识点豁然开朗, 此处只做记录, 不做展开;

## 如果要匹配任意字符怎么办

可以使用 `[\d\D]`、`[\w\W]`、`[\s\S]` 和 `[^]` 中任何的一个。

## 贪婪匹配与惰性匹配表示法

通过在量词后面加个问号就能实现惰性匹配

|  惰性量词 　　 | 贪婪量词 |
| -------------- | -------- |
| {m,n}?         | {m,n}    |
| {m,}?          | {m,}     |
| ??             | ?        |
| +?             | +        |
| \*?            | \*       |

## 位置匹配

ES6 正则的位置表示方式总共有: `^`、 `$`、`\b`、`\B`、`(?=)`、`(?!)`、`(?<=)`、`(?<!)`

其中`\b`和`\B`表示什么位置?

::: tip \b 与\B 用法:

\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 \$ 之间的位置。

\B 是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。
:::

## 括号匹配

分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配; 反向引用也是一样的;

```js
var regex = /(\d)+/;
var string = "12345";
console.log(string.match(regex));
// => ["12345", "5", index: 0, input: "12345"]
```

## 匹配回溯

一般语言中(包括 JS)使用的正则引擎是 NFA(非确定型有限自动机),导致匹配回溯的类型主要是三种:

- 贪婪量词

  少用贪婪量词(`. + ? *`)等

- 惰性量词

  虽然惰性量词不贪，但也会有回溯的现象。比如正则是 `\d{1,3}?\d{1,3}`

- 分支结构

  分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分
  支。

## 操作符优先性

| 操作符描述   | 操作符                                  | 优先级 |
| ------------ | --------------------------------------- | ------ |
| 转义符       | \                                       | 1      |
| 括号和方括号 | (...)、(?:...)、(?=...)、(?!...)、[...] | 2      |
| 量词限定符   | {m}、{m,n}、{m,}、?、\*、+              | 3      |
| 位置和序列   | ^、\$、\元字符、一般字符                | 4      |
| 管道符(竖杠) | \|                                      | 5      |

## 正则表达式的构建

- 平衡法则

- 构建正则前提

## 表达式编程

... 未完待续
