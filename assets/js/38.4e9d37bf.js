(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{416:function(s,t,v){"use strict";v.r(t);var a=v(27),_=Object(a.a)({},(function(){var s=this,t=s.$createElement,v=s._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h1",{attrs:{id:"服务器推送"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送"}},[s._v("#")]),s._v(" 服务器推送")]),s._v(" "),v("blockquote",[v("p",[s._v("服务器主动向浏览器推送数据转自"),v("a",{attrs:{href:"https://www.toutiao.com/a6763041921074987534/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1574691957&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=20191125222557010020047016214E56A1&group_id=6763041921074987534",target:"_blank",rel:"noopener noreferrer"}},[s._v("网络"),v("OutboundLink")],1)])]),s._v(" "),v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),v("p",[s._v("前面我们已经聊了 ajax，它的特点是浏览器必须先发起请求，服务器才能给出对应的响应，想一想能不能让服务器主动向浏览器推送数据呢？那么这篇文章我们来聊一聊服务器推送功能。")]),s._v(" "),v("h2",{attrs:{id:"轮询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#轮询"}},[s._v("#")]),s._v(" 轮询")]),s._v(" "),v("p",[s._v("假设你现在需要去做一个球赛直播页面，一个主播在后台文字直播比赛，那么这就要求解说数据尽可能的实时到达浏览器，那么我们如何解决呢？")]),s._v(" "),v("p",[s._v("最容易想到的就是用 ajax 轮询，写个定时器，每隔几秒钟去后端请求一次数据，这当然是可以的，但是这种方式并不是很优雅。因为浏览器每次需要主动去询问服务器有没有数据，如果反过来服务器有数据能主动告之浏览器岂不是更好？")]),s._v(" "),v("h2",{attrs:{id:"初识推送"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#初识推送"}},[s._v("#")]),s._v(" 初识推送")]),s._v(" "),v("p",[s._v("那么如何能让服务器自己主动推送数据呢？下面我们先实现一下服务端的代码，如下：")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061gy1g9anrh70jkj20hs0f70tp.jpg",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 1")]),s._v(" "),v("p",[s._v("如图 1，我们用 express 起了一个小服务，每当服务器接收到请求在响应时就会把 Content-type 设置为 text/event-stream，这是实现服务器推送的关键，它表示这次链接采用流实现并且整个页面生命周期都保持这一个链接的打开状态！")]),s._v(" "),v("p",[s._v("页面上的实现和普通 ajax 类似，但也有点不同，如下")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061gy1g9ans77i5aj20hs0b1wf3.jpg",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 2")]),s._v(" "),v("p",[s._v("如图 2，获取数据时的状态是在 3，因为此链接一直处于打开状态。")]),s._v(" "),v("p",[s._v("当你同时运行服务端和客户端的代码时，你会发现浏览器控制台会一直打印 123，此刻我们就已经实现了服务器推送的功能。")]),s._v(" "),v("h2",{attrs:{id:"sse"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sse"}},[s._v("#")]),s._v(" SSE")]),s._v(" "),v("p",[s._v("根据上面介绍的服务器推送的特点，浏览器自身也实现了这样的接口——SSE。")]),s._v(" "),v("p",[s._v("我们先看一下浏览器端如何使用，如下：")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061gy1g9anslt25oj20hs0f8wfd.jpg",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 3")]),s._v(" "),v("p",[s._v("如图 3，使用 EventSource 创建一个实例对象，参数是流实现的接口，下面绑定了几个事件，")]),s._v(" "),v("ul",[v("li",[s._v("open，当连接上之后就会立即触发；")]),s._v(" "),v("li",[s._v("message，服务器向客户端发送数据的默认事件，通过 e.data 可以获取到数据；")]),s._v(" "),v("li",[s._v("foo，自定义事件（SSE 支持自定义事件）；")]),s._v(" "),v("li",[s._v("error，当链接发生错误时触发。")])]),s._v(" "),v("p",[s._v("下面我们再看一下服务端实现，如下：")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061gy1g9ansvj1rsj20hs0ec74z.jpg",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 4")]),s._v(" "),v("p",[s._v("如图 4 所示，和图 1 中的代码雷同，先起一下服务端，再打开页面，看一下现象：")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061gy1g9antckdfbg20ga0hsqv6.gif",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 5")]),s._v(" "),v("p",[s._v("从现象看我们已经实现了服务器推送，符合预期，很好！但是要注意图 4 中响应数据时的写法，以 data: 开头会默认触发页面中 message 事件，以\\n\\n 结尾结束一次推送，如果一行写不下可以用\\n 分割；")]),s._v(" "),v("p",[s._v("下面我们看看如何触发自定义事件，代码如下：")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061gy1g9anto5tnvj20hs0d50te.jpg",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 6")]),s._v(" "),v("p",[s._v("如图 6，我们加一行字符串——'event:' + 事件名 + '\\n'，这样就会触发页面中的 foo 事件而不是 message 事件，现象如下：")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061gy1g9antzwmpig20fb0hsb2b.gif",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 7")]),s._v(" "),v("p",[s._v("据说 SSE 具有断线重连能力，我们试一下，看看是真是假？")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061ly1g9anx1lz5vg20dz0hs4r0.gif",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 8")]),s._v(" "),v("p",[s._v('图 8 证明传言不虚，当把服务关掉，页面在不停的尝试重连，当服务再次启动，页面就会立马链接上。如果服务端在发送数据时加一行字符串——"retry: " + 时间 + "\\n\\n" ，可以设置断开后重新再链接的间隔时间，这个就不演示了。')]),s._v(" "),v("p",[s._v('到目前为止，推送还是无状态的，如果链接断开了，再次重连，服务器是不知道先前已经推送了什么数据，为了解决这个问题，在每次推送时可以加一行字符串——"id: " + 序号 + "\\n"，如下：')]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061ly1g9anxdsfimj20hs0f2756.jpg",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 9")]),s._v(" "),v("p",[s._v("我们再来看一下现象，如下：")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061ly1g9anxqojgrg20e70hs1l1.gif",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 10")]),s._v(" "),v("p",[s._v("这个序号在页面上用事件对象的 lastEventId 属性可以拿到，当下一次重新连接时，浏览器会把最后一次序号放在请求头的 Last-Event-ID 字段中，所以服务端可以通过这个请求头属性获取之前数据推送的情况。")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blog/skills/servers-push/715b1061ly1g9any0t5e9j20hs0cyab1.jpg",alt:"详解前端如何让服务器主动向浏览器推送数据"}})]),s._v(" "),v("p",[s._v("图 11")]),s._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),v("p",[s._v("这篇文章主要讲解 SSE 如何使用，它是浏览器自带的 API，如果浏览器不兼容，我们也可以对它做兼容。从以上的介绍可以看出它是单向的，连接后只能是服务器向浏览器推送，所以它非常适合仅有查询的需求，像球赛直播、股票类的需求。")])])}),[],!1,null,null,null);t.default=_.exports}}]);